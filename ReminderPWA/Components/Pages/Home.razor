@page "/"
@inject HttpClient Http
@using ReminderTabletNew2.Models
@using ReminderTabletNew2.Services
@using System.Text.Json
@using System.Text
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@inject TelegramService TelegramService
@inject ApiService ApiService
@implements IDisposable

<AudioNotificationService @ref="audioService" OnAudioInitialized="OnAudioReady" />
<OfflineIndicator IsOffline="@isOfflineMode" 
                  OfflineMessage="@offlineMessage"
                  OnRetry="RetryConnection"
                  IsRetrying="@isRetrying" />

<SwipeContainer OnSwipe="HandleSwipe" CssClass="main-swipe-container">
    @* Dynamic view based on time of day *@
    @if (CurrentView == ViewMode.StartDay)
    {
        <StartDayView ApiResponse="@apiResponse" OnStartDayClicked="OnStartDayClicked" />
    }
    else
    {
        <TimeBasedView TimeOfDay="@GetTimeBasedViewMode()" 
                       CurrentTime="@currentTime"
                       ApiResponse="@apiResponse" 
                       OnAcknowledgeTask="OnAcknowledgeTaskHandler"
                       OnNavigateToWeekly="GoToWeeklyScheduleAsync"
                       OnNavigateToContacts="GoToContactsAsync"
                       OnStartExercise="OnStartExerciseHandler"
                       IsNewMessage="@IsNewMessage" />
    }
</SwipeContainer>

@* Auto-return timer display *@
@if (AutoReturnSecondsLeft > 0)
{
    <div class="auto-return-notification">
        <span class="icon">‚Ü∂</span>
        <span class="text">Paluu p√§√§n√§kym√§√§n @AutoReturnSecondsLeft s</span>
    </div>
}

@* Telegram floating button *@
@if (!isInTelegramMode && CurrentView != ViewMode.StartDay)
{
    <button class="telegram-float-btn" @onclick="ShowTelegram" title="L√§het√§ viesti perheelle">
        üì±
    </button>
}

@* Telegram sender modal *@
<TelegramSender IsVisible="@isInTelegramMode" 
                OnMessageSent="OnTelegramMessageSent"
                OnClose="HideTelegram" />

@code {
    public enum ViewMode
    {
        StartDay,    // Early morning before first message
        Morning,     // 08:00-11:00
        Day,         // 11:00-16:00
        Evening,     // 16:00-21:00
        Night        // 21:00+
    }
    
    private ViewMode CurrentView = ViewMode.StartDay;
    private PeriodicTimer? timer;
    private PeriodicTimer? autoReturnTimer;
    private DateTime currentTime = DateTime.Now;
    private string statusMessage = "Ladataan tietoja...";
    private ReminderApiResponse? apiResponse;
    private bool IsNewMessage => true; // TODO: Track when new message arrives
    
    // Auto-return functionality
    private int AutoReturnSecondsLeft = 0;
    private bool isInAlternativeView = false;
    
    // Telegram functionality
    private bool isInTelegramMode = false;
    
    // Offline mode tracking
    private bool isOfflineMode = false;
    private string offlineMessage = "";
    private bool isRetrying = false;
    
    // Audio service
    private AudioNotificationService? audioService;
    private bool audioReady = false;
    private DateTime lastMessageTime = DateTime.MinValue;

    protected override async Task OnInitializedAsync()
    {
        // Update time once initially
        currentTime = DateTime.Now;

        // Determine initial view
        UpdateCurrentView();

        // Start simple timer
        StartTimer();

                 // Fetch initial data
        await LoadData();
        
        // Check for new messages periodically
        _ = StartPeriodicMessageCheck();
    }

    private void StartTimer()
    {
        timer = new PeriodicTimer(TimeSpan.FromSeconds(1));
        _ = UpdateTimeLoop();
    }

    private async Task UpdateTimeLoop()
    {
        try
        {
            while (timer != null && await timer.WaitForNextTickAsync())
            {
                await InvokeAsync(() =>
                {
                    currentTime = DateTime.Now;
                    UpdateCurrentView();
                    StateHasChanged();
                });
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Timer error: {ex.Message}");
        }
    }

    private async Task LoadData()
    {
        statusMessage = "üì° Haetaan tietoja...";
        
        var result = await ApiService.GetDataAsync("mom", maxRetries: 2); // Only 2 retries for faster UX
        
        if (result.IsSuccess && result.Data != null)
        {
            apiResponse = result.Data;
            isOfflineMode = false;
            statusMessage = $"‚úÖ Tiedot ladattu {DateTime.Now:HH:mm:ss}";
            
                         if (apiResponse != null)
            {
                statusMessage = $"Tietojen haku onnistui. Viimeisin p√§ivitys: {DateTime.Now:HH:mm:ss}";
                
                // Debug: Log tasks data
                if (apiResponse.DailyTasks?.Any() == true)
                {
                                    Console.WriteLine("=== DAILYTASKS DEBUG ===");
                foreach(var task in apiResponse.DailyTasks)
                {
                    Console.WriteLine($"Task: {task.Type}, RequiresAck: {task.RequiresAck}, IsAckedToday: {task.IsAckedToday}, Desc: {task.Description}");
                }
                Console.WriteLine("========================");
            }
            else
            {
                Console.WriteLine("=== NO DAILYTASKS FOUND ===");
                Console.WriteLine("No tasks found from API - this is normal after acknowledgment");
            }

            // ALWAYS check and add missing data regardless of tasks
            // Add test important message if none exists
            if (string.IsNullOrEmpty(apiResponse.ImportantMessage))
            {
                apiResponse.ImportantMessage = TestDataService.GetDefaultImportantMessage();
                Console.WriteLine("Added test important message");
            }
            
            // Add test weather if none exists (backend handles 4x daily updates)
            if (apiResponse.Weather == null)
            {
                apiResponse.Weather = TestDataService.GetDefaultWeather();
                Console.WriteLine($"Added test weather data (backend will handle real updates)");
            }
            
            // Add test exercise video URL if none exists  
            if (string.IsNullOrEmpty(apiResponse.ExerciseVideoUrl))
            {
                apiResponse.ExerciseVideoUrl = TestDataService.GetDefaultExerciseVideoUrl();
                Console.WriteLine("Added test exercise video URL");
            }
            
            // KORJATTU: Ei lis√§t√§ placeholder kuvia - k√§ytet√§√§n vain API:sta tulevia kuvia
            // if (string.IsNullOrEmpty(apiResponse.DailyPhotoUrl))
            // {
            //     apiResponse.DailyPhotoUrl = TestDataService.GetDefaultPhotoUrl();
            //     apiResponse.DailyPhotoCaption = TestDataService.GetDefaultPhotoCaption();
            //     Console.WriteLine("Added test photo data");
            // }

            // KORJAUS: Lis√§√§ default teht√§v√§t jos API ei palauta teht√§vi√§
            if (apiResponse.DailyTasks?.Any() != true)
            {
                // DEBUGGING: Logitetaan syy miksi ei teht√§vi√§
                Console.WriteLine($"üîç No tasks from API. Status: '{apiResponse.Status}', DailyTasks count: {apiResponse.DailyTasks?.Count ?? 0}");
                
                // Lis√§√§ default teht√§v√§t aina kun API ei palauta teht√§vi√§
                // Jos teht√§v√§t on todella kuitattu, API palauttaa ne IsAckedToday=true kanssa
                apiResponse.DailyTasks = TestDataService.GetDefaultTasks();
                Console.WriteLine("Added default tasks - frontend will handle acknowledgment display logic");
            }
            }
            else
            {
                statusMessage = "Virhe: Google palautti tyhj√§n vastauksen";
            }
        }
        else
        {
            Console.WriteLine($"‚ùå API virhe: {result.ErrorCode} - {result.ErrorMessage}");
            isOfflineMode = true;
            offlineMessage = result.ErrorCode switch
            {
                "API_TIMEOUT" => "API vastaa hitaasti",
                "NETWORK_ERROR" => "Verkkoyhteys ongelma",
                "UNAUTHORIZED" => "API-avain virheellinen", 
                "JSON_ERROR" => "API vastaus virheellinen",
                "EMPTY_RESPONSE" => "API palautti tyhj√§n vastauksen",
                "HTML_RESPONSE" => "Google Apps Script URL virheellinen",
                _ => result.ErrorMessage
            };
            statusMessage = "üì± Offline-tila - k√§ytet√§√§n testidata";
            LoadFallbackData(result.ErrorCode);
        }
    }

    private void LoadFallbackData(string errorType)
    {
        apiResponse = new ReminderApiResponse
        {
            ClientID = "mom",
            Status = errorType, 
            Settings = new Settings { UseTelegram = false, UsePhotos = true },
            ImportantMessage = "üì± Offline-tila - API ei vastaa",
            UpcomingAppointments = TestDataService.GetDefaultAppointments(),
            DailyPhotoUrl = TestDataService.GetDefaultPhotoUrl(),
            DailyPhotoCaption = TestDataService.GetDefaultPhotoCaption(),
            Weather = TestDataService.GetDefaultWeather(),
            Contacts = TestDataService.GetDefaultContacts(),
            LatestReminder = "", // Tyhj√§ string - viestit tulevat vain API:sta oikeaan aikaan
            DailyTasks = TestDataService.GetDefaultTasks(),
            CurrentTimeOfDay = GetTimeOfDay()
        };
    }
    
         // Navigation methods moved to async versions below

    // Legacy method - keeping for backward compatibility
    // Vanha kuittausmetodi poistettu selkeyden vuoksi.
    // Uusi metodi on OnAcknowledgeTaskHandler.

    // Legacy methods - keeping for backward compatibility
    private string GetTaskIcon(string taskType)
    {
        return taskType.ToUpper() switch
        {
            "RUOKA" => "üçΩÔ∏è",
            "L√Ñ√ÑKKEET" => "üíä",
            "PUUHAA" => "‚òÄÔ∏è",
            _ => "üìã"
        };
    }

    private string GetTaskCssClass(string taskType)
    {
        return taskType.ToUpper() switch
        {
            "RUOKA" => "food-task",
            "L√Ñ√ÑKKEET" => "medicine-task",
            "PUUHAA" => "activity-task",
            _ => "general-task"
        };
    }

    private string GetTimeOfDay()
    {
        var hour = currentTime.Hour;
        if (hour >= 6 && hour < 11) return "AAMU";
        if (hour >= 11 && hour < 16) return "P√ÑIV√Ñ";
        if (hour >= 16 && hour < 21) return "ILTA";
        return "Y√ñ";
    }

    private void UpdateCurrentView()
    {
        var hour = currentTime.Hour;
        
        // Automaattisesti p√§ivit√§ n√§kym√§ ajan mukaan
        // Poista kiinte√§t return-lauseet jotta aika p√§ivittyy automaattisesti
        
        // StartDay n√§kym√§ vain varhain aamulla
        if (hour >= 5 && hour < 6)
        {
            CurrentView = ViewMode.StartDay;
        }
        else if (hour >= 6 && hour < 11)
        {
            CurrentView = ViewMode.Morning;
        }
        else if (hour >= 11 && hour < 16)
        {
            CurrentView = ViewMode.Day;
        }
        else if (hour >= 16 && hour < 21)
        {
            CurrentView = ViewMode.Evening;
        }
        else
        {
            CurrentView = ViewMode.Night;
        }
    }

    private async Task OnStartDayClicked()
    {
        CurrentView = ViewMode.Morning;
        
        // Play gentle transition sound
        if (audioReady && audioService != null)
        {
            await audioService.PlayNotificationSound("gentle");
        }
        
        StateHasChanged();
    }

    private TimeBasedView.ViewMode GetTimeBasedViewMode()
    {
        return CurrentView switch
        {
            ViewMode.Morning => TimeBasedView.ViewMode.Morning,
            ViewMode.Day => TimeBasedView.ViewMode.Day,
            ViewMode.Evening => TimeBasedView.ViewMode.Evening,
            ViewMode.Night => TimeBasedView.ViewMode.Night,
            _ => TimeBasedView.ViewMode.Morning
        };
    }

    private async Task OnAcknowledgeTaskHandler(TimeBasedView.TaskAckRequest request)
    {
        try
        {
            statusMessage = $"Kuittaan {request.TaskType}...";
            
            // Use ApiService for acknowledgment to ensure consistent URL and API key
            var success = await ApiService.AcknowledgeTaskAsync(request.TaskType, request.TimeOfDay, request.Description);

            if (success)
            {
                statusMessage = $"‚úÖ {request.TaskType} kuitattu! Ilmoitus l√§hetetty perheelle.";
                await OnTaskAcknowledged(); // Play completion sound
                
                Console.WriteLine($"üîÑ Waiting 3 seconds before reloading data for task: {request.TaskType} - {request.Description}");
                
                // Reload data after longer delay to ensure Google Sheets has updated
                await Task.Delay(3000); 
                
                Console.WriteLine("üîÑ Reloading data now...");
                await LoadData();
                
                Console.WriteLine("üîÑ Data reload completed");
            }
            else
            {
                statusMessage = $"‚ùå Kuittaus ep√§onnistui";
                Console.WriteLine($"Acknowledgment failed for {request.TaskType}");
            }
        }
        catch (Exception ex)
        {
            statusMessage = $"‚ùå Kuittausvirhe: {ex.Message}";
            Console.WriteLine($"Exception during acknowledgment: {ex}");
        }
    }

    private async Task HandleSwipe(string direction)
    {
        Console.WriteLine($"Swipe detected: {direction}");
        
        // Play swipe sound
        await OnSwipePerformed();
        
        if (direction == "right")
        {
            // Right swipe - go to WeeklySchedule or Contacts
            if (!isInAlternativeView)
            {
                await GoToWeeklyScheduleAsync();
            }
        }
        else if (direction == "left")
        {
            // Left swipe - return to start day view or main view
            if (isInAlternativeView)
            {
                await ReturnToMainView();
            }
            else
            {
                CurrentView = ViewMode.StartDay;
                StateHasChanged();
            }
        }
    }

    private async Task GoToWeeklyScheduleAsync()
    {
        isInAlternativeView = true;
        Navigation.NavigateTo("/weeklyschedule");
        await StartAutoReturn();
    }

    private async Task GoToContactsAsync()
    {
        isInAlternativeView = true;
        Navigation.NavigateTo("/contacts");
        await StartAutoReturn();
    }

    private async Task StartAutoReturn()
    {
        AutoReturnSecondsLeft = 60; // 1 minute
        autoReturnTimer = new PeriodicTimer(TimeSpan.FromSeconds(1));
        _ = AutoReturnCountdown();
    }

    private async Task AutoReturnCountdown()
    {
        try
        {
            while (autoReturnTimer != null && await autoReturnTimer.WaitForNextTickAsync())
            {
                await InvokeAsync(() =>
                {
                    AutoReturnSecondsLeft--;
                    if (AutoReturnSecondsLeft <= 0)
                    {
                        _ = ReturnToMainView();
                        return;
                    }
                    StateHasChanged();
                });
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Auto-return timer error: {ex.Message}");
        }
    }

    private async Task ReturnToMainView()
    {
        isInAlternativeView = false;
        AutoReturnSecondsLeft = 0;
        autoReturnTimer?.Dispose();
        autoReturnTimer = null;
        Navigation.NavigateTo("/");
        StateHasChanged();
    }

         // Legacy navigation methods (for backward compatibility) - removed duplicates

    private void OnAudioReady()
    {
        audioReady = true;
        Console.WriteLine("Audio service is ready");
    }

    private async Task CheckForNewMessages()
    {
        if (!audioReady || audioService == null) return;
        
        // Check if we have a new message (simplified logic)
        if (apiResponse?.LatestReminder != null)
        {
            var messageHash = apiResponse.LatestReminder.GetHashCode();
            var currentTime = DateTime.Now;
            
            // If message content changed or it's been more than 5 minutes since last check
            if (lastMessageTime == DateTime.MinValue || 
                (currentTime - lastMessageTime).TotalMinutes >= 5)
            {
                lastMessageTime = currentTime;
                
                // Play notification sound
                await audioService.PlayNewMessageSound();
                
                // Start bell animation for 15 seconds
                await audioService.StartBellAnimation(15);
                
                                 Console.WriteLine("New message notification played");
             }
         }
     }

         private async Task StartPeriodicMessageCheck()
    {
        var lastWeatherUpdate = DateTime.MinValue;
        var lastHourCheck = -1;
        
        while (true)
        {
            await Task.Delay(TimeSpan.FromMinutes(1)); // Check every minute
            await CheckForNewMessages();
            
            var currentHour = DateTime.Now.Hour;
            
            // P√§ivit√§ s√§√§tiedot 4x p√§iv√§ss√§: 6, 12, 18, 24 (keskiy√∂)
            if ((currentHour == 6 || currentHour == 12 || currentHour == 18 || currentHour == 0) && 
                currentHour != lastHourCheck)
            {
                Console.WriteLine($"üå§Ô∏è S√§√§tiedon automaattinen p√§ivitys klo {currentHour}:00");
                await LoadData(); // Lataa uudet s√§√§tiedot
                lastHourCheck = currentHour;
                lastWeatherUpdate = DateTime.Now;
            }
            
            // Varmista ett√§ s√§√§tiedot p√§ivittyv√§t v√§hint√§√§n 4h v√§lein
            if (DateTime.Now - lastWeatherUpdate > TimeSpan.FromHours(4))
            {
                Console.WriteLine("üå§Ô∏è S√§√§tiedon pakollinen p√§ivitys (4h ylittynyt)");
                await LoadData();
                lastWeatherUpdate = DateTime.Now;
            }
        }
    }

    private async Task OnTaskAcknowledged()
    {
        if (audioReady && audioService != null)
        {
            await audioService.PlayTaskCompletedSound();
        }
    }

    private async Task OnSwipePerformed()
    {
        if (audioReady && audioService != null)
        {
            await audioService.PlaySwipeSound();
        }
    }

    private async Task OnStartExerciseHandler()
    {
        Console.WriteLine("Starting exercise video...");
        
        if (audioReady && audioService != null)
        {
            await audioService.PlayNotificationSound("gentle");
        }
        
        // Check if we have a video URL from the API
        if (!string.IsNullOrEmpty(apiResponse?.ExerciseVideoUrl))
        {
            // Open video in new tab/window
            await JSRuntime.InvokeVoidAsync("window.open", apiResponse.ExerciseVideoUrl, "_blank");
        }
        else
        {
            // Use default/test video URL
            var defaultVideoUrl = "https://www.youtube.com/watch?v=dQw4w9WgXcQ"; // Placeholder
            await JSRuntime.InvokeVoidAsync("window.open", defaultVideoUrl, "_blank");
        }
        
        statusMessage = "üèÉ‚Äç‚ôÄÔ∏è Jumppa-video avattu! Hyv√§√§ treeni√§!";
    }

    // Telegram handler methods
    private void ShowTelegram()
    {
        isInTelegramMode = true;
        StateHasChanged();
    }

    private void HideTelegram()
    {
        isInTelegramMode = false;
        StateHasChanged();
    }

    private async Task OnTelegramMessageSent()
    {
        // Reload data to show any updates
        await LoadData();
        
        // Play success sound
        if (audioReady && audioService != null)
        {
            await audioService.PlayNotificationSound("gentle");
        }
        
        statusMessage = "üì± Viesti l√§hetetty perheelle!";
    }

    private async Task RetryConnection()
    {
        if (isRetrying) return;
        
        isRetrying = true;
        Console.WriteLine("üîÑ Yritet√§√§n yhdist√§√§ uudelleen...");
        
        try
        {
            await LoadData();
        }
        finally
        {
            isRetrying = false;
        }
    }

     public void Dispose()
     {
         timer?.Dispose();
         autoReturnTimer?.Dispose();
         audioService?.StopBellAnimation();
     }
} 