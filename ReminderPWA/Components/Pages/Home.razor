@page "/"
@inject HttpClient Http
@using ReminderTabletNew2.Models
@using ReminderTabletNew2.Services
@using System.Text.Json
@using System.Text
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@inject TelegramService TelegramService
@inject ApiService ApiService
@implements IDisposable

<AudioNotificationService @ref="audioService" OnAudioInitialized="OnAudioReady" />
@if (!isInitializing && isOfflineMode)
{
    <OfflineIndicator IsOffline="@isOfflineMode" 
                      OfflineMessage="@offlineMessage"
                      OnRetry="RetryConnection"
                      IsRetrying="@isRetrying" />
}

@if (apiResponse == null)
{
    <div class="app-loading">
        <div class="spinner">‚è≥</div>
        <div class="text">Ladataan...</div>
    </div>
}
else
{
<SwipeContainer OnSwipe="HandleSwipe" CssClass="main-swipe-container">
    <TimeBasedView TimeOfDay="@GetTimeBasedViewMode()" 
                   CurrentTime="@currentTime"
                   ApiResponse="@apiResponse" 
                   OnAcknowledgeTask="OnAcknowledgeTaskHandler"
                   OnNavigateToWeekly="GoToWeeklyScheduleAsync"
                   OnNavigateToContacts="GoToContactsAsync"
                   OnStartExercise="OnStartExerciseHandler"
                   OnShowTelegram="ShowTelegram"
                   IsNewMessage="@IsNewMessage" />
</SwipeContainer>
}

@* Auto-return timer display *@
@if (AutoReturnSecondsLeft > 0)
{
    <div class="auto-return-notification">
        <span class="icon">‚Ü∂</span>
        <span class="text">Paluu p√§√§n√§kym√§√§n @AutoReturnSecondsLeft s</span>
    </div>
}

@* Tablet-k√§ytt√∂: ei kelluvia nappeja, kaikki toiminnot alapalkissa *@

@* Telegram sender modal *@
<TelegramSender IsVisible="@isInTelegramMode" 
                TargetTelegramChatId="@prefillChatId"
                OnMessageSent="OnTelegramMessageSent"
                OnClose="HideTelegram" />

@code {
    public enum ViewMode
    {
        StartDay,    // Early morning before first message
        Morning,     // 08:00-11:00
        Day,         // 11:00-16:00
        Evening,     // 16:00-21:00
        Night        // 21:00+
    }
    
    private ViewMode CurrentView = ViewMode.StartDay;
    private PeriodicTimer? timer;
    private PeriodicTimer? autoReturnTimer;
    private DateTime currentTime = DateTime.Now;
    private string statusMessage = "Ladataan tietoja...";
    private ReminderApiResponse? apiResponse;
    private bool IsNewMessage => true; // TODO: Track when new message arrives
    
    // Paikallinen kuittausmuisti: pit√§√§ visuaalisen tilan kuitattuna hetken
    private readonly Dictionary<string, DateTime> recentlyAckedTaskKeysUtc = new();
    private static readonly TimeSpan LocalAckTtl = TimeSpan.FromMinutes(30);
    
    // Auto-return functionality
    private int AutoReturnSecondsLeft = 0;
    private bool isInAlternativeView = false;
    
    // Telegram functionality
    private bool isInTelegramMode = false;
    
    // Offline mode tracking
    private bool isOfflineMode = false;
    private string offlineMessage = "";
    private bool isRetrying = false;
    
    // Audio service
    private AudioNotificationService? audioService;
    private bool audioReady = false;
    private DateTime lastMessageTime = DateTime.MinValue;
    // Ilmoituksen soittaminen vain aidossa muutoksessa
    private int? lastContentHash = null;
    private string? prefillChatId = null;
    private int consecutiveFailures = 0;
    private DateTime lastSuccessfulFetch = DateTime.MinValue;
    private DateTime appStartTime = DateTime.Now;
    private bool isInitializing = true;

    protected override async Task OnInitializedAsync()
    {
        // Update time once initially
        currentTime = DateTime.Now;

        // Determine initial view
        UpdateCurrentView();

        // Start simple timer
        StartTimer();

                 // Fetch initial data (stale-while-revalidate)
        await LoadLocalAcknowledgmentsAsync();
        // Prefill chat from localStorage if set (coming from Contacts)
        try { prefillChatId = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "prefillTelegramChatId"); } catch {}
        if (!string.IsNullOrWhiteSpace(prefillChatId))
        {
            isInTelegramMode = true;
            await JSRuntime.InvokeVoidAsync("localStorage.removeItem", "prefillTelegramChatId");
        }
        await LoadCachedDataIfAny();
        await LoadData(initialFast: true);
        // Taustalla perusteellisempi p√§ivitys (photo + weeklyPlan), pidempi timeout
        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Delay(200); // pieni heng√§hdys UI:lle
                await LoadData(initialFast: false);
                Console.WriteLine("üü¢ Heavy refresh valmis");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Heavy refresh failed: {ex.Message}");
            }
        });
        
        // Check for new messages periodically
        _ = StartPeriodicMessageCheck();
    }

    private void StartTimer()
    {
        timer = new PeriodicTimer(TimeSpan.FromSeconds(1));
        _ = UpdateTimeLoop();
    }

    private async Task UpdateTimeLoop()
    {
        try
        {
            while (timer != null && await timer.WaitForNextTickAsync())
            {
                await InvokeAsync(() =>
                {
                    currentTime = DateTime.Now;
                    UpdateCurrentView();
                    StateHasChanged();
                });
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Timer error: {ex.Message}");
        }
    }

    private async Task LoadData(bool initialFast = false)
    {
        Console.WriteLine("üîÑ LoadData() aloitettu - haetaan uudet tiedot API:sta");
        statusMessage = "üì° Haetaan tietoja...";
        
        var result = await ApiService.GetDataAsync("mom", maxRetries: initialFast ? 1 : 2, timeoutOverrideSeconds: initialFast ? 12 : null); // pidempi timeout k√§ynnistyksess√§
        
        if (result.IsSuccess && result.Data != null)
        {
            apiResponse = result.Data;
            isOfflineMode = false;
            consecutiveFailures = 0;
            lastSuccessfulFetch = DateTime.Now;
            statusMessage = $"‚úÖ Tiedot ladattu {DateTime.Now:HH:mm:ss}";
            
                         if (apiResponse != null)
            {
                statusMessage = $"Tietojen haku onnistui. Viimeisin p√§ivitys: {DateTime.Now:HH:mm:ss}";
                
                // Debug: Log tasks data
                if (apiResponse.DailyTasks?.Any() == true)
                {
                                    Console.WriteLine("=== DAILYTASKS DEBUG ===");
                foreach(var task in apiResponse.DailyTasks)
                {
                    Console.WriteLine($"Task: {task.Type}, RequiresAck: {task.RequiresAck}, IsAckedToday: {task.IsAckedToday}, Desc: {task.Description}");
                }
                Console.WriteLine("========================");
                // Cache
                await SaveCacheAsync(apiResponse);
                isInitializing = false;
            }
            else
            {
                Console.WriteLine("=== NO DAILYTASKS FOUND ===");
                Console.WriteLine("No tasks found from API - this is normal after acknowledgment");
            }

            // ALWAYS check and add missing data regardless of tasks
            // Add test important message if none exists
            if (string.IsNullOrEmpty(apiResponse.ImportantMessage))
            {
                apiResponse.ImportantMessage = TestDataService.GetDefaultImportantMessage();
                Console.WriteLine("Added test important message");
            }
            
            // Add test weather if none exists (backend handles 4x daily updates)
            if (apiResponse.Weather == null)
            {
                apiResponse.Weather = TestDataService.GetDefaultWeather();
                Console.WriteLine($"Added test weather data (backend will handle real updates)");
            }
            
            // Add test exercise video URL if none exists  
            if (string.IsNullOrEmpty(apiResponse.ExerciseVideoUrl))
            {
                apiResponse.ExerciseVideoUrl = TestDataService.GetDefaultExerciseVideoUrl();
                Console.WriteLine("Added test exercise video URL");
            }
            
            // KORJATTU: Ei lis√§t√§ placeholder kuvia - k√§ytet√§√§n vain API:sta tulevia kuvia
            // if (string.IsNullOrEmpty(apiResponse.DailyPhotoUrl))
            // {
            //     apiResponse.DailyPhotoUrl = TestDataService.GetDefaultPhotoUrl();
            //     apiResponse.DailyPhotoCaption = TestDataService.GetDefaultPhotoCaption();
            //     Console.WriteLine("Added test photo data");
            // }

            // √ÑL√Ñ lis√§√§ testiteht√§vi√§ online-tilassa ‚Äì muutoin kuittauksen j√§lkeen ne palaavat

                    // Sovella paikalliset (viime minuuttien) kuittaukset heti
                    ApplyLocalAcknowledgments();
            }
            else
            {
                statusMessage = "Virhe: Google palautti tyhj√§n vastauksen";
            }
        }
        else
        {
            Console.WriteLine($"‚ùå API virhe: {result.ErrorCode} - {result.ErrorMessage}");
            consecutiveFailures++;

            // √Ñl√§ mene offline-tilaan heti; salli 2 per√§kk√§ist√§ ep√§onnistumista ja tarkista viimeinen onnistuminen
            var gracePeriodNotOver = (DateTime.Now - appStartTime) < TimeSpan.FromSeconds(25);
            var shouldGoOffline = !gracePeriodNotOver && consecutiveFailures >= 2 && (lastSuccessfulFetch == DateTime.MinValue || DateTime.Now - lastSuccessfulFetch > TimeSpan.FromSeconds(30));

            if (shouldGoOffline)
            {
                isOfflineMode = true;
                offlineMessage = result.ErrorCode switch
                {
                    "API_TIMEOUT" => "API vastaa hitaasti",
                    "NETWORK_ERROR" => "Verkkoyhteys ongelma",
                    "UNAUTHORIZED" => "API-avain virheellinen", 
                    "JSON_ERROR" => "API vastaus virheellinen",
                    "EMPTY_RESPONSE" => "API palautti tyhj√§n vastauksen",
                    "HTML_RESPONSE" => "Google Apps Script URL virheellinen",
                    _ => result.ErrorMessage
                };
                statusMessage = "üì± Offline-tila - k√§ytet√§√§n v√§limuistia";
                // √Ñl√§ korvaa n√§kym√§√§ testidatalla jos meill√§ on cache
                if (apiResponse == null)
                {
                    LoadFallbackData(result.ErrorCode);
                }
            }
            else
            {
                // Pysy online-tilassa ja pid√§ cache n√§kyviss√§, yritet√§√§n my√∂hemmin uudelleen
                Console.WriteLine("‚åõ Pidet√§√§n nykyinen n√§kym√§, ei siirryt√§ offline-tilaan (pehme√§ virhe)");
                // jos meill√§ ei viel√§ ole dataa, n√§yt√§ latausn√§kym√§ eik√§ offlinea
                if (apiResponse == null) isInitializing = true;
            }
        }
    }

    private async Task LoadCachedDataIfAny()
    {
        try
        {
            var json = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "lastApiResponse");
            if (!string.IsNullOrWhiteSpace(json))
            {
                var cached = System.Text.Json.JsonSerializer.Deserialize<ReminderApiResponse>(json);
                if (cached != null)
                {
                    apiResponse = cached;
                    Console.WriteLine("üì¶ N√§ytet√§√§n v√§limuistidata heti");
                    StateHasChanged();
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"LoadCachedDataIfAny error: {ex.Message}");
        }
    }

    private async Task SaveCacheAsync(ReminderApiResponse data)
    {
        try
        {
            var json = System.Text.Json.JsonSerializer.Serialize(data);
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", "lastApiResponse", json);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"SaveCacheAsync error: {ex.Message}");
        }
    }

    private void ApplyLocalAcknowledgments()
    {
        try
        {
            // Poista vanhentuneet merkinn√§t (TTL)
            var now = DateTime.UtcNow;
            var expiredKeys = recentlyAckedTaskKeysUtc.Where(kv => (now - kv.Value) > LocalAckTtl)
                                                      .Select(kv => kv.Key)
                                                      .ToList();
            foreach (var key in expiredKeys)
            {
                recentlyAckedTaskKeysUtc.Remove(key);
            }

            if (apiResponse?.DailyTasks == null) return;
            foreach (var t in apiResponse.DailyTasks)
            {
                var tod = string.IsNullOrEmpty(t.TimeOfDay) ? GetTimeOfDay() : t.TimeOfDay;
                var keyExact = BuildTaskKey(t.Type, tod);
                var keyAny = BuildTaskKey(t.Type, "*");
                if (recentlyAckedTaskKeysUtc.ContainsKey(keyExact) || recentlyAckedTaskKeysUtc.ContainsKey(keyAny))
                {
                    t.IsAckedToday = true;
                    if (string.IsNullOrEmpty(t.AcknowledgmentTimestamp))
                    {
                        t.AcknowledgmentTimestamp = DateTime.UtcNow.ToString("yyyy-MM-ddTHH:mm:ss.fffZ");
                    }
                }
            }

            // Persistoi localStorageen
            _ = SaveLocalAcknowledgmentsAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ApplyLocalAcknowledgments error: {ex.Message}");
        }
    }

    private void RegisterLocalAcknowledgment(string taskType, string timeOfDay)
    {
        var now = DateTime.UtcNow;
        // Tallenna sek√§ tarkka ett√§ "mik√§ tahansa vuorokaudenaika" -avaimet
        recentlyAckedTaskKeysUtc[BuildTaskKey(taskType, timeOfDay)] = now;
        recentlyAckedTaskKeysUtc[BuildTaskKey(taskType, "*")] = now;

        _ = SaveLocalAcknowledgmentsAsync();
    }

    private static string BuildTaskKey(string taskType, string timeOfDay)
    {
        return $"{(taskType ?? "").Trim().ToUpperInvariant()}|{(timeOfDay ?? "").Trim().ToUpperInvariant()}";
    }

    private async Task LoadLocalAcknowledgmentsAsync()
    {
        try
        {
            var json = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "recentAcks");
            if (!string.IsNullOrWhiteSpace(json))
            {
                var dict = System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, string>>(json);
                if (dict != null)
                {
                    recentlyAckedTaskKeysUtc.Clear();
                    foreach (var kv in dict)
                    {
                        if (DateTime.TryParse(kv.Value, out var dt))
                        {
                            recentlyAckedTaskKeysUtc[kv.Key] = dt;
                        }
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"LoadLocalAcknowledgmentsAsync error: {ex.Message}");
        }
    }

    private async Task SaveLocalAcknowledgmentsAsync()
    {
        try
        {
            var dict = recentlyAckedTaskKeysUtc.ToDictionary(k => k.Key, v => v.Value.ToString("o"));
            var json = System.Text.Json.JsonSerializer.Serialize(dict);
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", "recentAcks", json);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"SaveLocalAcknowledgmentsAsync error: {ex.Message}");
        }
    }

    private void LoadFallbackData(string errorType)
    {
        apiResponse = new ReminderApiResponse
        {
            ClientID = "mom",
            Status = errorType, 
            Settings = new Settings { UseTelegram = false, UsePhotos = true },
            ImportantMessage = "üì± Offline-tila - API ei vastaa",
            UpcomingAppointments = TestDataService.GetDefaultAppointments(),
            DailyPhotoUrl = TestDataService.GetDefaultPhotoUrl(),
            DailyPhotoCaption = TestDataService.GetDefaultPhotoCaption(),
            Weather = TestDataService.GetDefaultWeather(),
            Contacts = TestDataService.GetDefaultContacts(),
            LatestReminder = "", // Tyhj√§ string - viestit tulevat vain API:sta oikeaan aikaan
            DailyTasks = TestDataService.GetDefaultTasks(),
            CurrentTimeOfDay = GetTimeOfDay()
        };
    }
    
         // Navigation methods moved to async versions below

    // Legacy method - keeping for backward compatibility
    // Vanha kuittausmetodi poistettu selkeyden vuoksi.
    // Uusi metodi on OnAcknowledgeTaskHandler.

    // Legacy methods - keeping for backward compatibility
    private string GetTaskIcon(string taskType)
    {
        return taskType.ToUpper() switch
        {
            "RUOKA" => "üçΩÔ∏è",
            "L√Ñ√ÑKKEET" => "üíä",
            "PUUHAA" => "‚òÄÔ∏è",
            _ => "üìã"
        };
    }

    private string GetTaskCssClass(string taskType)
    {
        return taskType.ToUpper() switch
        {
            "RUOKA" => "food-task",
            "L√Ñ√ÑKKEET" => "medicine-task",
            "PUUHAA" => "activity-task",
            _ => "general-task"
        };
    }

    private string GetTimeOfDay()
    {
        var hour = currentTime.Hour;
        if (hour >= 6 && hour < 11) return "AAMU";
        if (hour >= 11 && hour < 16) return "P√ÑIV√Ñ";
        if (hour >= 16 && hour < 21) return "ILTA";
        return "Y√ñ";
    }

    private void UpdateCurrentView()
    {
        var hour = currentTime.Hour;
        
        // Automaattisesti p√§ivit√§ n√§kym√§ ajan mukaan
        // Poista kiinte√§t return-lauseet jotta aika p√§ivittyy automaattisesti
        
        // StartDay n√§kym√§ vain varhain aamulla
        if (hour >= 5 && hour < 6)
        {
            CurrentView = ViewMode.StartDay;
        }
        else if (hour >= 6 && hour < 11)
        {
            CurrentView = ViewMode.Morning;
        }
        else if (hour >= 11 && hour < 16)
        {
            CurrentView = ViewMode.Day;
        }
        else if (hour >= 16 && hour < 21)
        {
            CurrentView = ViewMode.Evening;
        }
        else
        {
            CurrentView = ViewMode.Night;
        }
    }

    private async Task OnStartDayClicked()
    {
        CurrentView = ViewMode.Morning;
        
        // Play gentle transition sound
        if (audioReady && audioService != null)
        {
            await audioService.PlayNotificationSound("gentle");
        }
        
        StateHasChanged();
    }

    private TimeBasedView.ViewMode GetTimeBasedViewMode()
    {
        return CurrentView switch
        {
            ViewMode.Morning => TimeBasedView.ViewMode.Morning,
            ViewMode.Day => TimeBasedView.ViewMode.Day,
            ViewMode.Evening => TimeBasedView.ViewMode.Evening,
            ViewMode.Night => TimeBasedView.ViewMode.Night,
            _ => TimeBasedView.ViewMode.Morning
        };
    }

    private async Task OnAcknowledgeTaskHandler(TimeBasedView.TaskAckRequest request)
    {
        try
        {
            Console.WriteLine($"üîò KUITTAUS ALOITETTU: {request.TaskType} - {request.Description} ({request.TimeOfDay})");
            statusMessage = $"Kuittaan {request.TaskType}...";
            
            // Use ApiService for acknowledgment to ensure consistent URL and API key
            var success = await ApiService.AcknowledgeTaskAsync(request.TaskType, request.TimeOfDay, request.Description);

            if (success)
            {
                statusMessage = $"‚úÖ {request.TaskType} kuitattu! Ilmoitus l√§hetetty perheelle.";
                await OnTaskAcknowledged(); // Play completion sound
                
                // Optimistinen UI-p√§ivitys: merkitse vastaavat teht√§v√§t kuitatuiksi heti
                try
                {
                    if (apiResponse?.DailyTasks != null)
                    {
                        foreach (var t in apiResponse.DailyTasks)
                        {
                            var typeMatches = string.Equals(t.Type, request.TaskType, StringComparison.OrdinalIgnoreCase);
                            var timeMatches = string.IsNullOrEmpty(t.TimeOfDay) || string.Equals(t.TimeOfDay, request.TimeOfDay, StringComparison.OrdinalIgnoreCase);

                            if (typeMatches && timeMatches)
                            {
                                t.IsAckedToday = true;
                                t.AcknowledgmentTimestamp = DateTime.UtcNow.ToString("yyyy-MM-ddTHH:mm:ss.fffZ");
                            }
                        }

                        StateHasChanged();
                    }

                    // Rekister√∂i paikallinen kuittaus, jotta uudelleenlataus ei kumoa n√§kym√§√§
                    RegisterLocalAcknowledgment(request.TaskType, request.TimeOfDay);
                }
                catch { /* ignore optimistic update errors */ }

                Console.WriteLine($"üîÑ Waiting 3 seconds before reloading data for task: {request.TaskType} - {request.Description}");
                
                // Reload data after longer delay to ensure Google Sheets has updated
                await Task.Delay(3000); 
                
                Console.WriteLine("üîÑ Reloading data now...");
                await LoadData();
                
                Console.WriteLine("üîÑ Data reload completed - forcing UI refresh");
                StateHasChanged(); // üîÑ PAKOTA UI P√ÑIVITYS!
            }
            else
            {
                statusMessage = $"‚ùå Kuittaus ep√§onnistui";
                Console.WriteLine($"Acknowledgment failed for {request.TaskType}");
            }
        }
        catch (Exception ex)
        {
            statusMessage = $"‚ùå Kuittausvirhe: {ex.Message}";
            Console.WriteLine($"Exception during acknowledgment: {ex}");
        }
    }

    private async Task HandleSwipe(string direction)
    {
        Console.WriteLine($"Swipe detected: {direction}");
        
        // Play swipe sound
        await OnSwipePerformed();
        
        if (direction == "right")
        {
            // Right swipe - go to WeeklySchedule or Contacts
            if (!isInAlternativeView)
            {
                await GoToWeeklyScheduleAsync();
            }
        }
        else if (direction == "left")
        {
            // Left swipe - return to start day view or main view
            if (isInAlternativeView)
            {
                await ReturnToMainView();
            }
            else
            {
                CurrentView = ViewMode.StartDay;
                StateHasChanged();
            }
        }
    }

    private async Task GoToWeeklyScheduleAsync()
    {
        isInAlternativeView = true;
        Navigation.NavigateTo("/weeklyschedule");
        await StartAutoReturn();
    }

    private async Task GoToContactsAsync()
    {
        isInAlternativeView = true;
        Navigation.NavigateTo("/contacts");
        await StartAutoReturn();
    }

    private async Task StartAutoReturn()
    {
        AutoReturnSecondsLeft = 60; // 1 minute
        autoReturnTimer = new PeriodicTimer(TimeSpan.FromSeconds(1));
        _ = AutoReturnCountdown();
    }

    private async Task AutoReturnCountdown()
    {
        try
        {
            while (autoReturnTimer != null && await autoReturnTimer.WaitForNextTickAsync())
            {
                await InvokeAsync(() =>
                {
                    AutoReturnSecondsLeft--;
                    if (AutoReturnSecondsLeft <= 0)
                    {
                        _ = ReturnToMainView();
                        return;
                    }
                    StateHasChanged();
                });
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Auto-return timer error: {ex.Message}");
        }
    }

    private async Task ReturnToMainView()
    {
        isInAlternativeView = false;
        AutoReturnSecondsLeft = 0;
        autoReturnTimer?.Dispose();
        autoReturnTimer = null;
        Navigation.NavigateTo("/");
        StateHasChanged();
    }

         // Legacy navigation methods (for backward compatibility) - removed duplicates

    private void OnAudioReady()
    {
        audioReady = true;
        Console.WriteLine("Audio service is ready");
    }

    private async Task CheckForNewMessages()
    {
        if (!audioReady || audioService == null) return;
        if (apiResponse == null) return;

        // Koosta yksinkertainen sis√§lt√∂allekirjoitus (muuta vain kun tieto vaihtuu)
        var tasksSig = string.Empty;
        if (apiResponse.DailyTasks != null)
        {
            tasksSig = string.Join("|", apiResponse.DailyTasks
                .Where(t => t.RequiresAck)
                .Select(t => $"{t.Type}:{t.Description}:{t.IsAckedToday}"));
        }

        var signature = $"{apiResponse.LatestReminder}|{apiResponse.ImportantMessage}|{apiResponse.DailyPhotoUrl}|{apiResponse.DailyPhotoCaption}|{tasksSig}";
        var contentHash = signature.GetHashCode();

        // Ensimm√§isell√§ kerralla √§l√§ soita ‚Äì ota vain tilanne talteen
        if (lastContentHash == null)
        {
            lastContentHash = contentHash;
            lastMessageTime = DateTime.Now;
            return;
        }

        if (lastContentHash != contentHash)
        {
            lastContentHash = contentHash;
            lastMessageTime = DateTime.Now;

            await audioService.PlayNewMessageSound();
            await audioService.StartBellAnimation(15);
            Console.WriteLine("üîî Notification played (content changed)");
        }
    }

         private async Task StartPeriodicMessageCheck()
    {
        var lastWeatherUpdate = DateTime.MinValue;
        var lastHourCheck = -1;
        
        while (true)
        {
            await Task.Delay(TimeSpan.FromMinutes(1)); // Check every minute
            await CheckForNewMessages();
            
            var currentHour = DateTime.Now.Hour;
            
            // P√§ivit√§ s√§√§tiedot 4x p√§iv√§ss√§: 6, 12, 18, 24 (keskiy√∂)
            if ((currentHour == 6 || currentHour == 12 || currentHour == 18 || currentHour == 0) && 
                currentHour != lastHourCheck)
            {
                Console.WriteLine($"üå§Ô∏è S√§√§tiedon automaattinen p√§ivitys klo {currentHour}:00");
                await LoadData(); // Lataa uudet s√§√§tiedot
                lastHourCheck = currentHour;
                lastWeatherUpdate = DateTime.Now;
            }
            
            // Varmista ett√§ s√§√§tiedot p√§ivittyv√§t v√§hint√§√§n 4h v√§lein
            if (DateTime.Now - lastWeatherUpdate > TimeSpan.FromHours(4))
            {
                Console.WriteLine("üå§Ô∏è S√§√§tiedon pakollinen p√§ivitys (4h ylittynyt)");
                await LoadData();
                lastWeatherUpdate = DateTime.Now;
            }
        }
    }

    private async Task OnTaskAcknowledged()
    {
        if (audioReady && audioService != null)
        {
            await audioService.PlayTaskCompletedSound();
        }
    }

    private async Task OnSwipePerformed()
    {
        if (audioReady && audioService != null)
        {
            await audioService.PlaySwipeSound();
        }
    }

    private async Task OnStartExerciseHandler()
    {
        Console.WriteLine("Starting exercise video...");
        
        if (audioReady && audioService != null)
        {
            await audioService.PlayNotificationSound("gentle");
        }
        
        // Check if we have a video URL from the API
        if (!string.IsNullOrEmpty(apiResponse?.ExerciseVideoUrl))
        {
            // Open video in new tab/window
            await JSRuntime.InvokeVoidAsync("window.open", apiResponse.ExerciseVideoUrl, "_blank");
        }
        else
        {
            // Use default/test video URL
            var defaultVideoUrl = "https://www.youtube.com/watch?v=dQw4w9WgXcQ"; // Placeholder
            await JSRuntime.InvokeVoidAsync("window.open", defaultVideoUrl, "_blank");
        }
        
        statusMessage = "üèÉ‚Äç‚ôÄÔ∏è Jumppa-video avattu! Hyv√§√§ treeni√§!";
    }

    // Telegram handler methods
    private void ShowTelegram()
    {
        isInTelegramMode = true;
        StateHasChanged();
    }

    private void HideTelegram()
    {
        isInTelegramMode = false;
        StateHasChanged();
    }

    private async Task OnTelegramMessageSent()
    {
        // Reload data to show any updates
        await LoadData();
        
        // Play success sound
        if (audioReady && audioService != null)
        {
            await audioService.PlayNotificationSound("gentle");
        }
        
        statusMessage = "üì± Viesti l√§hetetty perheelle!";
    }

    private async Task ClearCache()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("localStorage.removeItem", "lastApiResponse");
            await JSRuntime.InvokeVoidAsync("localStorage.removeItem", "recentAcks");
            statusMessage = "üóëÔ∏è V√§limuisti tyhjennetty";
            Console.WriteLine("Cache cleared: lastApiResponse + recentAcks");
            // Hae tuore data nopeasti
            await LoadData(initialFast: true);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ClearCache error: {ex.Message}");
        }
    }

    private async Task RetryConnection()
    {
        if (isRetrying) return;
        
        isRetrying = true;
        Console.WriteLine("üîÑ Yritet√§√§n yhdist√§√§ uudelleen...");
        
        try
        {
            await LoadData();
        }
        finally
        {
            isRetrying = false;
        }
    }

     public void Dispose()
     {
         timer?.Dispose();
         autoReturnTimer?.Dispose();
         audioService?.StopBellAnimation();
     }
} 